{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Oolong Oolong is an Elm inspired Model-View-Update (MVU) implementation for Kotlin multiplatform. As the name implies, three core concepts comprise the foundation of this architecture: Model - a type to represent the program state View - a function to map the state to view properties Update - a function to update the state By applying this simple pattern you can create composable, testable programs that can run on any platform. Oolong enables a common codebase for all platforms by using a render function which is implemented by each frontend. An example Here is a simple example in which a number can be incremented or decremented. data class Model ( val count : Int = 0 ) sealed class Msg { object Increment : Msg () object Decrement : Msg () } class Props ( val count : Int , val increment : () -> Unit , val decrement : () -> Unit , ) val init : () -> Pair < Model , Effect < Msg >> = { Model () to none () } val update : ( Msg , Model ) -> Pair < Model , Effect < Msg >> = { msg , model -> when ( msg ) { Msg . Increment -> next ( model . copy ( count = model . count + 1 )) Msg . Decrement -> next ( model . copy ( count = model . count - 1 )) } } val view : ( Model , Dispatch < Msg > ) -> Props = { model -> Props ( model . count , { dispatch ( Msg . Increment ) }, { dispatch ( Msg . Decrement ) }, ) }","title":"Overview"},{"location":"#oolong","text":"Oolong is an Elm inspired Model-View-Update (MVU) implementation for Kotlin multiplatform. As the name implies, three core concepts comprise the foundation of this architecture: Model - a type to represent the program state View - a function to map the state to view properties Update - a function to update the state By applying this simple pattern you can create composable, testable programs that can run on any platform. Oolong enables a common codebase for all platforms by using a render function which is implemented by each frontend.","title":"Oolong"},{"location":"#an-example","text":"Here is a simple example in which a number can be incremented or decremented. data class Model ( val count : Int = 0 ) sealed class Msg { object Increment : Msg () object Decrement : Msg () } class Props ( val count : Int , val increment : () -> Unit , val decrement : () -> Unit , ) val init : () -> Pair < Model , Effect < Msg >> = { Model () to none () } val update : ( Msg , Model ) -> Pair < Model , Effect < Msg >> = { msg , model -> when ( msg ) { Msg . Increment -> next ( model . copy ( count = model . count + 1 )) Msg . Decrement -> next ( model . copy ( count = model . count - 1 )) } } val view : ( Model , Dispatch < Msg > ) -> Props = { model -> Props ( model . count , { dispatch ( Msg . Increment ) }, { dispatch ( Msg . Decrement ) }, ) }","title":"An example"},{"location":"changelog/","text":"Changelog Unreleased Added Changed Deprecated Removed Fixed Security 2.1.1 - 2022-08-03 Added Update Kotlin to 1.7.10 Update Kotlin Coroutines to 1.6.4 Add a next builder function. Runtime factory that passes dispatch to view instead of render . Changed View function changed from (Model) -> Props as (Model, Dispatch<Msg>) -> Props . Render function changed from (Props, Dispatch<Msg>) -> Any? to (Props) -> Any? . Deprecated Runtime factories that pass dispatch to render instead of view . Removed Remove deprecated type aliases. 2.1.0 - 2020-09-28 Added Add a runtime overload which combines view and render . Update Kotlin to 1.4.10 Changed CoroutineDispatcher replaced with CoroutineContext in runtime builder. Dispatch deprecated in favor of Job . oolong.Oolong.runtime deprecated in favor of oolong.runtime . disposableEffect deprecated. Allow incoming types to be nullable. Deprecate Next , Init , Update , View , and Render in preference of underlying types. 2.0.7 - 2020-08-17 Added Update Kotlin to 1.4.0 Update Kotlin Coroutines to 1.3.9 2.0.6 - 2020-06-30 Fixed Maven Central artifacts. 2.0.5 - 2020-06-10 Added Update Kotlin Coroutines to 1.3.7 2.0.4 - 2020-05-17 Added Update Kotlin Coroutines to 1.3.6 Add samples link to readme Fixed Allow dispatcher specification. 2.0.3 - 2020-04-25 Added Update Kotlin to 1.3.72 Update Kotlin Coroutines to 1.3.5 Removed Deprecated coroutine scope and context arguments in runtime creator function. Remove deprecated runtime creator function. 2.0.2 - 2020-01-08 Added Update Kotlin to 1.3.61 Update Kotlin Coroutines to 1.3.3 Removed Samples moved to https://github.com/oolong-kt/oolong-samples 2.0.1 - 2019-06-20 Added Update Kotlin to 1.3.40 Changed Remove default arguments for Runtime constructor 2.0.0 - 2019-05-31 Added Add samples Changed Move to oolong-kt org and update packages Change core types from classes to functions 1.0.0 - 2018-08-01 Initial release","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#added","text":"","title":"Added"},{"location":"changelog/#changed","text":"","title":"Changed"},{"location":"changelog/#deprecated","text":"","title":"Deprecated"},{"location":"changelog/#removed","text":"","title":"Removed"},{"location":"changelog/#fixed","text":"","title":"Fixed"},{"location":"changelog/#security","text":"","title":"Security"},{"location":"changelog/#211-2022-08-03","text":"","title":"2.1.1 - 2022-08-03"},{"location":"changelog/#added_1","text":"Update Kotlin to 1.7.10 Update Kotlin Coroutines to 1.6.4 Add a next builder function. Runtime factory that passes dispatch to view instead of render .","title":"Added"},{"location":"changelog/#changed_1","text":"View function changed from (Model) -> Props as (Model, Dispatch<Msg>) -> Props . Render function changed from (Props, Dispatch<Msg>) -> Any? to (Props) -> Any? .","title":"Changed"},{"location":"changelog/#deprecated_1","text":"Runtime factories that pass dispatch to render instead of view .","title":"Deprecated"},{"location":"changelog/#removed_1","text":"Remove deprecated type aliases.","title":"Removed"},{"location":"changelog/#210-2020-09-28","text":"","title":"2.1.0 - 2020-09-28"},{"location":"changelog/#added_2","text":"Add a runtime overload which combines view and render . Update Kotlin to 1.4.10","title":"Added"},{"location":"changelog/#changed_2","text":"CoroutineDispatcher replaced with CoroutineContext in runtime builder. Dispatch deprecated in favor of Job . oolong.Oolong.runtime deprecated in favor of oolong.runtime . disposableEffect deprecated. Allow incoming types to be nullable. Deprecate Next , Init , Update , View , and Render in preference of underlying types.","title":"Changed"},{"location":"changelog/#207-2020-08-17","text":"","title":"2.0.7 - 2020-08-17"},{"location":"changelog/#added_3","text":"Update Kotlin to 1.4.0 Update Kotlin Coroutines to 1.3.9","title":"Added"},{"location":"changelog/#206-2020-06-30","text":"","title":"2.0.6 - 2020-06-30"},{"location":"changelog/#fixed_1","text":"Maven Central artifacts.","title":"Fixed"},{"location":"changelog/#205-2020-06-10","text":"","title":"2.0.5 - 2020-06-10"},{"location":"changelog/#added_4","text":"Update Kotlin Coroutines to 1.3.7","title":"Added"},{"location":"changelog/#204-2020-05-17","text":"","title":"2.0.4 - 2020-05-17"},{"location":"changelog/#added_5","text":"Update Kotlin Coroutines to 1.3.6 Add samples link to readme","title":"Added"},{"location":"changelog/#fixed_2","text":"Allow dispatcher specification.","title":"Fixed"},{"location":"changelog/#203-2020-04-25","text":"","title":"2.0.3 - 2020-04-25"},{"location":"changelog/#added_6","text":"Update Kotlin to 1.3.72 Update Kotlin Coroutines to 1.3.5","title":"Added"},{"location":"changelog/#removed_2","text":"Deprecated coroutine scope and context arguments in runtime creator function. Remove deprecated runtime creator function.","title":"Removed"},{"location":"changelog/#202-2020-01-08","text":"","title":"2.0.2 - 2020-01-08"},{"location":"changelog/#added_7","text":"Update Kotlin to 1.3.61 Update Kotlin Coroutines to 1.3.3","title":"Added"},{"location":"changelog/#removed_3","text":"Samples moved to https://github.com/oolong-kt/oolong-samples","title":"Removed"},{"location":"changelog/#201-2019-06-20","text":"","title":"2.0.1 - 2019-06-20"},{"location":"changelog/#added_8","text":"Update Kotlin to 1.3.40","title":"Added"},{"location":"changelog/#changed_3","text":"Remove default arguments for Runtime constructor","title":"Changed"},{"location":"changelog/#200-2019-05-31","text":"","title":"2.0.0 - 2019-05-31"},{"location":"changelog/#added_9","text":"Add samples","title":"Added"},{"location":"changelog/#changed_4","text":"Move to oolong-kt org and update packages Change core types from classes to functions","title":"Changed"},{"location":"changelog/#100-2018-08-01","text":"Initial release","title":"1.0.0 - 2018-08-01"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at community@oolong-kt.org. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at community@oolong-kt.org. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"guide/core-concepts/","text":"Core Concepts Let's visit each of the core concepts by examining a simple example. We'll create a simple \"counter\" program that can increment and decrement an Int state. In MVU architecture, state is changed by dispatching and handling messages. We'll look at this more in a moment. First let's take a look at the model. Model The model is a representation of the state of your application. In this case, the model contains just one property which is an Int named count with a default value of 0 . By convention, we define the model as a data class so it can be mutated easily. While your application is running, the model will be changing from one state to the next every time a message is dispatched. data class Model ( val count : Int = 0 ) Update Messages Before looking at the update function, let's talk about messages. Messages describe the way we want the application state to change. In the case of our counter app, we have two messages that can be dispatched and handled: Increment and Decrement . Increment adds 1 to the current value of count and Decrement subtracts 1 from count . By convention, messages are defined as part of a sealed interface. This allows us to use an exhaustive list of types when interpreting messages. sealed interface Msg { object Increment : Msg object Decrement : Msg } Update function The update function uses these two concepts to take a previous state and transform it to the next state. When a message is dispatched, the update function is called with the dispatched message and the current state as arguments. The function must determine what state to return given these arguments. So far we have mentioned two conventions: models are data classes, and messages are sealed interfaces. You can see in the function below how those modifiers are leveraged. The message type is able to be determined in an exhaustive manner using the when block. The new state is created by mutating the old state with the copy function. val update : ( Msg , Model ) -> Pair < Model , Effect < Msg >> = { msg , model -> when ( msg ) { Msg . Increment -> next ( model . copy ( count = model . count + 1 )) Msg . Decrement -> next ( model . copy ( count = model . count - 1 )) } } View The job of the view function is to transform the current state into something that can be rendered in a UI. This could be an HTML string, a tree of widgets, or in multiplatform projects it will be a simple data structure. We call this output type view properties or Props . View properties There are two types of data you may want to store in your view properties. First is information that you want to be rendered to the UI, and in this case we want to show the current count. The second category of data is dispatching functions. Your rendering code will know how to display properties and call dispatch functions from user events. If you are only targeting one platform then you may decide to return components specific to that platform, but since Oolong is a multiplatform library it is convention to use a hierarchical data structure. class Props ( val count : Int , val increment : () -> Unit , val decrement : () -> Unit , ) View function The view function, as mentioned above, takes the current state and a dispatch function as its arguments and returns view properties. In our counter example we populate the view properties with: count - the current count. increment - a function which dispatches the Increment message. decrement - a function which dispatches the Decrement message. val view : ( Model , Dispatch < Msg > ) -> Props = { model -> Props ( model . count , { dispatch ( Msg . Increment ) }, { dispatch ( Msg . Decrement ) }, ) } Putting it all together Now that we've built the core components of our application we need a few more things to complete it, namely a way to create an initial application state and a way to render the view properties. Initialization function To get the runtime loop started, we first need to know what the initial state is. We do this by defining an initialization function. This function is similar to the update function, however it takes no arguments. By convention, it is often desirable to define defaults in the model class and simply return a new instance from the init function. val init : () -> Pair < Model , Effect < Msg >> = { next ( Model ()) } Render function We also need to know how to render the view properties returned by the view function. Each target platform does this by implementing a render function which takes the view properties and a dispatch function as arguments. The dispatch function can be invoked to send messages to the update function. val render : ( Props ) -> Any? = { props , dispatch -> // Platform specific rendering countLabel . text = \" ${ props . count } \" incrementButton . setOnClickListener { props . increment () } decrementButton . setOnClickListener { props . decrement () } } Runtime The Oolong runtime composes these core functions into a user interaction loop, continually moving from one state to the next. It also handles things like side-effects (which we'll see in the next chapter) and resource disposal. You can start this loop by calling Oolong.runtime . val dispose = Oolong . runtime ( init , update , view , render , )","title":"Core Concepts"},{"location":"guide/core-concepts/#core-concepts","text":"Let's visit each of the core concepts by examining a simple example. We'll create a simple \"counter\" program that can increment and decrement an Int state. In MVU architecture, state is changed by dispatching and handling messages. We'll look at this more in a moment. First let's take a look at the model.","title":"Core Concepts"},{"location":"guide/core-concepts/#model","text":"The model is a representation of the state of your application. In this case, the model contains just one property which is an Int named count with a default value of 0 . By convention, we define the model as a data class so it can be mutated easily. While your application is running, the model will be changing from one state to the next every time a message is dispatched. data class Model ( val count : Int = 0 )","title":"Model"},{"location":"guide/core-concepts/#update","text":"","title":"Update"},{"location":"guide/core-concepts/#messages","text":"Before looking at the update function, let's talk about messages. Messages describe the way we want the application state to change. In the case of our counter app, we have two messages that can be dispatched and handled: Increment and Decrement . Increment adds 1 to the current value of count and Decrement subtracts 1 from count . By convention, messages are defined as part of a sealed interface. This allows us to use an exhaustive list of types when interpreting messages. sealed interface Msg { object Increment : Msg object Decrement : Msg }","title":"Messages"},{"location":"guide/core-concepts/#update-function","text":"The update function uses these two concepts to take a previous state and transform it to the next state. When a message is dispatched, the update function is called with the dispatched message and the current state as arguments. The function must determine what state to return given these arguments. So far we have mentioned two conventions: models are data classes, and messages are sealed interfaces. You can see in the function below how those modifiers are leveraged. The message type is able to be determined in an exhaustive manner using the when block. The new state is created by mutating the old state with the copy function. val update : ( Msg , Model ) -> Pair < Model , Effect < Msg >> = { msg , model -> when ( msg ) { Msg . Increment -> next ( model . copy ( count = model . count + 1 )) Msg . Decrement -> next ( model . copy ( count = model . count - 1 )) } }","title":"Update function"},{"location":"guide/core-concepts/#view","text":"The job of the view function is to transform the current state into something that can be rendered in a UI. This could be an HTML string, a tree of widgets, or in multiplatform projects it will be a simple data structure. We call this output type view properties or Props .","title":"View"},{"location":"guide/core-concepts/#view-properties","text":"There are two types of data you may want to store in your view properties. First is information that you want to be rendered to the UI, and in this case we want to show the current count. The second category of data is dispatching functions. Your rendering code will know how to display properties and call dispatch functions from user events. If you are only targeting one platform then you may decide to return components specific to that platform, but since Oolong is a multiplatform library it is convention to use a hierarchical data structure. class Props ( val count : Int , val increment : () -> Unit , val decrement : () -> Unit , )","title":"View properties"},{"location":"guide/core-concepts/#view-function","text":"The view function, as mentioned above, takes the current state and a dispatch function as its arguments and returns view properties. In our counter example we populate the view properties with: count - the current count. increment - a function which dispatches the Increment message. decrement - a function which dispatches the Decrement message. val view : ( Model , Dispatch < Msg > ) -> Props = { model -> Props ( model . count , { dispatch ( Msg . Increment ) }, { dispatch ( Msg . Decrement ) }, ) }","title":"View function"},{"location":"guide/core-concepts/#putting-it-all-together","text":"Now that we've built the core components of our application we need a few more things to complete it, namely a way to create an initial application state and a way to render the view properties.","title":"Putting it all together"},{"location":"guide/core-concepts/#initialization-function","text":"To get the runtime loop started, we first need to know what the initial state is. We do this by defining an initialization function. This function is similar to the update function, however it takes no arguments. By convention, it is often desirable to define defaults in the model class and simply return a new instance from the init function. val init : () -> Pair < Model , Effect < Msg >> = { next ( Model ()) }","title":"Initialization function"},{"location":"guide/core-concepts/#render-function","text":"We also need to know how to render the view properties returned by the view function. Each target platform does this by implementing a render function which takes the view properties and a dispatch function as arguments. The dispatch function can be invoked to send messages to the update function. val render : ( Props ) -> Any? = { props , dispatch -> // Platform specific rendering countLabel . text = \" ${ props . count } \" incrementButton . setOnClickListener { props . increment () } decrementButton . setOnClickListener { props . decrement () } }","title":"Render function"},{"location":"guide/core-concepts/#runtime","text":"The Oolong runtime composes these core functions into a user interaction loop, continually moving from one state to the next. It also handles things like side-effects (which we'll see in the next chapter) and resource disposal. You can start this loop by calling Oolong.runtime . val dispose = Oolong . runtime ( init , update , view , render , )","title":"Runtime"},{"location":"guide/rendering/","text":"Rendering Coming soon!","title":"Rendering"},{"location":"guide/rendering/#rendering","text":"Coming soon!","title":"Rendering"},{"location":"guide/side-effects/","text":"Side Effects A side effect is an operation that modifies some state outside of the local environment. HTTP requests, disk I/O, user input, and dispalying pixels on a screen are examples of side effects. As you can imagine, a program without side effects is not very useful at all. Functional programming loves pure functions and abhors side effects, so how can we perform effectful operations while keeping our code pure? MVU uses the concept of managed effects . Instead of performing effects in your purely functional core, you describe the effect and pass it off to the runtime where it can be safely executed. In Oolong, for each call to update we return a Next value. This value is a Pair comprised of the new state and an Effect . After getting the next value, the effect is launched in a new coroutine away from the runtime. Looking at the type of Effect you'll notice it takes a single argument of type Dispatch . typealias Effect<Msg> = suspend CoroutineScope.(dispatch: Dispatch<Msg>) -> Any? This is how you call back in to your purely functional code: by calling dispatch with an effect response message. Here's a simple example which dispatches a message after a short delay. val continueAfterDelayEffect = effect { dispatch -> delay ( 500 ) dispatch ( Msg . Continue ) } In this example, they delay is a stand-in for any time consuming operation that you might do, for example an HTTP request. An actual network effect might look like this: val getNetworkItemsEffect = effect { dispatch -> val response = itemNetworkRepository . getItems () val msg = when ( response ) { is Either . Left -> { Msg . GetNetworkItemsFailure ( response . value ) } is Either . Right -> { Msg . GetNetworkItemsSuccess ( response . value ) } } dispatch ( msg ) } For most updates, you may not want to perform any side effects. In this case you can just return an effect with an empty body or just use the provided none() function. At other times, you may want to return multiple effects. You can compose multiple effects using the batch() function. Oolong provides a few utility functions for common effects, which can be found in oolong.delay and oolong.random .","title":"Side Effects"},{"location":"guide/side-effects/#side-effects","text":"A side effect is an operation that modifies some state outside of the local environment. HTTP requests, disk I/O, user input, and dispalying pixels on a screen are examples of side effects. As you can imagine, a program without side effects is not very useful at all. Functional programming loves pure functions and abhors side effects, so how can we perform effectful operations while keeping our code pure? MVU uses the concept of managed effects . Instead of performing effects in your purely functional core, you describe the effect and pass it off to the runtime where it can be safely executed. In Oolong, for each call to update we return a Next value. This value is a Pair comprised of the new state and an Effect . After getting the next value, the effect is launched in a new coroutine away from the runtime. Looking at the type of Effect you'll notice it takes a single argument of type Dispatch . typealias Effect<Msg> = suspend CoroutineScope.(dispatch: Dispatch<Msg>) -> Any? This is how you call back in to your purely functional code: by calling dispatch with an effect response message. Here's a simple example which dispatches a message after a short delay. val continueAfterDelayEffect = effect { dispatch -> delay ( 500 ) dispatch ( Msg . Continue ) } In this example, they delay is a stand-in for any time consuming operation that you might do, for example an HTTP request. An actual network effect might look like this: val getNetworkItemsEffect = effect { dispatch -> val response = itemNetworkRepository . getItems () val msg = when ( response ) { is Either . Left -> { Msg . GetNetworkItemsFailure ( response . value ) } is Either . Right -> { Msg . GetNetworkItemsSuccess ( response . value ) } } dispatch ( msg ) } For most updates, you may not want to perform any side effects. In this case you can just return an effect with an empty body or just use the provided none() function. At other times, you may want to return multiple effects. You can compose multiple effects using the batch() function. Oolong provides a few utility functions for common effects, which can be found in oolong.delay and oolong.random .","title":"Side Effects"},{"location":"recipes/isolation/","text":"Isolation Coming soon!","title":"Isolation"},{"location":"recipes/isolation/#isolation","text":"Coming soon!","title":"Isolation"},{"location":"recipes/navigation/","text":"Navigation Since MVU architecture is fractal and composable, navigation is simply an excercise in composition and delegation. Let's look at a simple example with two screens: List and Detail . Data Structures The navigation component needs to have an awareness of the logical screens in order to delegate to them, so we must create Model , Msg , and Props wrappers for each screen. A navigation component's model consists of wrapper instances for each screen: sealed class Model { // Delegates data class List ( model : List . Model ) : Model () data class Detail ( model : Detail . Model ) : Model () } Similarly, delegated components also need wrappers for their message types. Additionally, we have defined a navigation message to set a new screen. sealed class Msg { // Delegates data class List ( msg : List . Msg ) : Msg () data class Detail ( msg : Detail . Msg ) : Msg () // Navigation data class SetScreen ( next : Pair < Model , Effect < Msg >> ): Msg () } Finally, we create delegation wrappers for each screen's props. sealed class Props { // Delegates data class List ( props : List . Props ) : Props () data class Detail ( props : Detail . Props ) : Props () } Functions Now that the appropriate types have been defined, we can define program functions which delegate to each screen. Let's look each function in order starting with init . Oolong provides a few utility functions for common use-cases and one of these is bimap . The bimap function transforms an instance of Pair<A, Effect<B>> to an instance of Pair<C, Effect<D>> . We're going to use List as our initial screen, so in this case we're bimapping from an instance of Pair<List.Model , Effect<List.Msg >> to an instance of Pair<Model, Effect<Msg>> . In other words, we're taking the List.Model and List.Msg returned from List.init and wrapping them in the delegated types of Model.List and Msg.List . val init : () -> Pair < Model , Effect < Msg >> = { bimap ( List . init (), Model :: List , Msg :: List ) } The same bimap function is used to delegate to screens in the update function. If the msg is an instance of a screen message wrapper, then we delegate to that screen using bimap . However, we receive a SetScreen message, we simply return the next value provided. val update : ( Msg , Model ) -> Pair < Model , Effect < Msg >> = { msg , model -> when ( msg ) { is Msg . List -> { bimap ( List . update ( msg . msg , ( model as Model . List ). model ), Model :: List , Msg :: List ) } is Msg . Detail -> { bimap ( Detail . update ( msg . msg , ( model as Model . Detail ). model ), Model :: Detail , Msg :: Detail ) } is Msg . SetScreen -> { msg . next } } } The view function is quite simple, as we only need to wrap the screen's props with it's respected instance in the navigation props. val view : ( Model ) -> Props = { model -> when ( model ) { is Model . List -> { Props . List ( List . view ( model . model )) } is Model . Detail -> { Props . Detail ( Detail . view ( model . model )) } } } Finally, in the view function we unwrap the props and delegate to each screen's render function. There is one additional consideration we need to take in this function, however, which is mapping the dispatch function from the screen's Msg type to the parent's. For this, we can use the provided contramap fuction. val render : ( Props , Dispatch < Msg > ) -> Any? = { props , dispatch -> when ( props ) { is Props . List -> { List . render ( props . props , contramap ( dispatch , Msg :: List )) } is Props . Detail -> { Detail . render ( props . props , contramap ( dispatch , Msg :: Detail )) } } } Navigating With our types and functions setup for the navigation component, changing screens is done by simply dispatching a SetScreen message with the initial state for that screen. How navigation is performed and dispatched is an excercise for the user on each platform. Typically, you will create an adapter for your backstack which dispatches SetScreen using the latest instance of dispatch . val navigateToItemDetail = { id : Long , dispatch : Dispatch < Msg > -> val init = Detail . makeInit ( id ) val next = bimap ( init (), Model :: Detail , Msg :: Detail ) dispatch ( Msg . SetScreen ( next )) }","title":"Navigation"},{"location":"recipes/navigation/#navigation","text":"Since MVU architecture is fractal and composable, navigation is simply an excercise in composition and delegation. Let's look at a simple example with two screens: List and Detail .","title":"Navigation"},{"location":"recipes/navigation/#data-structures","text":"The navigation component needs to have an awareness of the logical screens in order to delegate to them, so we must create Model , Msg , and Props wrappers for each screen. A navigation component's model consists of wrapper instances for each screen: sealed class Model { // Delegates data class List ( model : List . Model ) : Model () data class Detail ( model : Detail . Model ) : Model () } Similarly, delegated components also need wrappers for their message types. Additionally, we have defined a navigation message to set a new screen. sealed class Msg { // Delegates data class List ( msg : List . Msg ) : Msg () data class Detail ( msg : Detail . Msg ) : Msg () // Navigation data class SetScreen ( next : Pair < Model , Effect < Msg >> ): Msg () } Finally, we create delegation wrappers for each screen's props. sealed class Props { // Delegates data class List ( props : List . Props ) : Props () data class Detail ( props : Detail . Props ) : Props () }","title":"Data Structures"},{"location":"recipes/navigation/#functions","text":"Now that the appropriate types have been defined, we can define program functions which delegate to each screen. Let's look each function in order starting with init . Oolong provides a few utility functions for common use-cases and one of these is bimap . The bimap function transforms an instance of Pair<A, Effect<B>> to an instance of Pair<C, Effect<D>> . We're going to use List as our initial screen, so in this case we're bimapping from an instance of Pair<List.Model , Effect<List.Msg >> to an instance of Pair<Model, Effect<Msg>> . In other words, we're taking the List.Model and List.Msg returned from List.init and wrapping them in the delegated types of Model.List and Msg.List . val init : () -> Pair < Model , Effect < Msg >> = { bimap ( List . init (), Model :: List , Msg :: List ) } The same bimap function is used to delegate to screens in the update function. If the msg is an instance of a screen message wrapper, then we delegate to that screen using bimap . However, we receive a SetScreen message, we simply return the next value provided. val update : ( Msg , Model ) -> Pair < Model , Effect < Msg >> = { msg , model -> when ( msg ) { is Msg . List -> { bimap ( List . update ( msg . msg , ( model as Model . List ). model ), Model :: List , Msg :: List ) } is Msg . Detail -> { bimap ( Detail . update ( msg . msg , ( model as Model . Detail ). model ), Model :: Detail , Msg :: Detail ) } is Msg . SetScreen -> { msg . next } } } The view function is quite simple, as we only need to wrap the screen's props with it's respected instance in the navigation props. val view : ( Model ) -> Props = { model -> when ( model ) { is Model . List -> { Props . List ( List . view ( model . model )) } is Model . Detail -> { Props . Detail ( Detail . view ( model . model )) } } } Finally, in the view function we unwrap the props and delegate to each screen's render function. There is one additional consideration we need to take in this function, however, which is mapping the dispatch function from the screen's Msg type to the parent's. For this, we can use the provided contramap fuction. val render : ( Props , Dispatch < Msg > ) -> Any? = { props , dispatch -> when ( props ) { is Props . List -> { List . render ( props . props , contramap ( dispatch , Msg :: List )) } is Props . Detail -> { Detail . render ( props . props , contramap ( dispatch , Msg :: Detail )) } } }","title":"Functions"},{"location":"recipes/navigation/#navigating","text":"With our types and functions setup for the navigation component, changing screens is done by simply dispatching a SetScreen message with the initial state for that screen. How navigation is performed and dispatched is an excercise for the user on each platform. Typically, you will create an adapter for your backstack which dispatches SetScreen using the latest instance of dispatch . val navigateToItemDetail = { id : Long , dispatch : Dispatch < Msg > -> val init = Detail . makeInit ( id ) val next = bimap ( init (), Model :: Detail , Msg :: Detail ) dispatch ( Msg . SetScreen ( next )) }","title":"Navigating"},{"location":"samples/official/","text":"Counter A counter app demonstrating simple Msg updates. https://github.com/oolong-kt/samples/tree/master/samples/counter Random A random number generator demonstrating update effects. https://github.com/oolong-kt/samples/tree/master/samples/random Time A time display demonstrating init effects. https://github.com/oolong-kt/samples/tree/master/samples/time TodoMVC An implementation of TodoMVC https://github.com/oolong-kt/samples/tree/master/samples/todomvc","title":"Official"},{"location":"samples/official/#counter","text":"A counter app demonstrating simple Msg updates. https://github.com/oolong-kt/samples/tree/master/samples/counter","title":"Counter"},{"location":"samples/official/#random","text":"A random number generator demonstrating update effects. https://github.com/oolong-kt/samples/tree/master/samples/random","title":"Random"},{"location":"samples/official/#time","text":"A time display demonstrating init effects. https://github.com/oolong-kt/samples/tree/master/samples/time","title":"Time"},{"location":"samples/official/#todomvc","text":"An implementation of TodoMVC https://github.com/oolong-kt/samples/tree/master/samples/todomvc","title":"TodoMVC"},{"location":"samples/third-party/","text":"Lambda news A functional HackerNews client for Kotlin Multiplatform. https://github.com/pardom/lambda-news Dice A simple dice rolling app demonstrating a multiplatform functional architecture, with frontends for Android and iOS. https://github.com/pardom/dice","title":"Third-party"},{"location":"samples/third-party/#lambda-news","text":"A functional HackerNews client for Kotlin Multiplatform. https://github.com/pardom/lambda-news","title":"Lambda news"},{"location":"samples/third-party/#dice","text":"A simple dice rolling app demonstrating a multiplatform functional architecture, with frontends for Android and iOS. https://github.com/pardom/dice","title":"Dice"}]}